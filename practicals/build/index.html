<!doctype html>
<html lang="en">
    <head>
        
            <meta charset="utf-8">
            <meta name="robots" content="noindex">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            <meta name="author" content="Simon J Cockell" />
            <meta name="date" content="2022-06-22" />
        

        <title>MMB8052 - Practical 1 | </title>

        
    
    
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="static/styles.css">
            <link rel="stylesheet" id="customiseCSS" href="static/light.css">
            
            
        
    <link rel="stylesheet" id="customiseCodeCSS" href="static/pygmentize.light.css">
    <link rel="stylesheet" href="static/codemirror-5.26.0/lib/codemirror.css">
    <link rel="stylesheet" href="static/code.css">
    <link rel="stylesheet" href="static/numbasEmbed.css">

    <link rel="stylesheet" href="static/bootstrap-toc.css?v=3">
    <link rel="stylesheet" href="static/print.css">


        
    
    
			<script>
				var chirun_static_url="static/.";
			</script>
            <script defer src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
            <script defer src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
            <script defer src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
            <script defer src="static/mathjax_config.js"></script>
            <script type="text/javascript" id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
            <script defer src="static/customisation.js"></script>
            <script defer src="static/mp4.js"></script>
            
            
			</script>
        
    <script defer src="static/jquery.flexibleArea.js"></script>
    <script defer src="static/spin.min.js"></script>
    <script defer src="static/codemirror-5.26.0/lib/codemirror.js"></script>
    <script defer src="static/codemirror-5.26.0/mode/octave/octave.js"></script>
    <script defer src="static/codemirror-5.26.0/mode/python/python.js"></script>
    <script defer src="static/codemirror-5.26.0/mode/r/r.js"></script>
    <script defer src="static/code.js"></script>
    <script defer src="static/numbasEmbed.js"></script>

    <script defer src="static/bootstrap-toc.js"></script>

    </head>
    <body data-spy="scroll" data-target="#chapterTOC" data-offset="50">
        
<div class="collapse" id="navbarToggleCustomise">
	<div class="bg-secondary text-white p-3">
		<form onsubmit="return false;" id="navbarCustomise">
			<div class="form-row">
				<label>Theme Customisation</label>
				<div id="themeSelector" class="form-group col-md-12">
					<button class="btn btn-dark mr-2" value="dark">Dark</button>
					<button class="btn btn-pastel mr-2" value="pastel">Pastel</button>
					<button class="btn btn-light mr-4" value="light">Light</button>
				</div>
			</div>
			<div class="form-row">
				<div class="form-group col-md-4">
					<label style="display: block" for="font-scale">Font size (<span id="font-size-display">100%</span>)</label>
					<input type="range" class="form-control-range col-9 mr-2" id="font-scale" min="50" max="600" value="100">
					<button id="font-scale-reset" class="btn btn-sm">Reset</button>
				</div>
				<div class="form-group col-md-4">
					<label style="display: block" for="p-space">Spacing (<span id="p-space-display">100%</span>)</label>
					<input type="range" class="form-control-range col-9 mr-2" id="p-space" min="0" max="600" value="100">
					<button id="p-space-reset" class="btn btn-sm">Reset</button>
				</div>
			</div>
		</form>
	</div>
</div>

<nav aria-label="breadcrumb">
	<ul class="breadcrumb">
		<li class="breadcrumb-item">
			<a href="index.html"></a>
		</li>
		
		<li class="breadcrumb-item active">
			MMB8052 - Practical 1
		</li>
		<li class="ml-auto">
			<button class="navbar-toggler p0" type="button" data-toggle="collapse" data-target="#navbarToggleCustomise" aria-controls="navbarToggleCustomise" aria-expanded="false" aria-label="Toggle customisations panel">
				<i class="fa fa-cog" aria-hidden="true" title="Toggle customisations panel"></i> <span class="sr-only">Toggle customisations panel</span>
			</button>
		</li>
	</ul>
</nav>


        <header>
            
            
        </header>
        <main>
            
    <div class="container mt-3">
        <div class="row">
            
            <div id="sidebar" class="col-md-3">
                <nav class="mb-3" id="chapterTOC" data-toggle="toc">
                    <ul class="nav navbar-nav">
                        
                        
                        
                        <li><a id="pdf-link" class="nav-link" href="mmb8052__practical_1.pdf" target="_blank"><i class="fa fa-file-pdf-o" aria-hidden="true" title="Download as PDF"></i>&nbsp;Download as PDF</a></li>
                        
                    </ul>
                </nav>
            </div>
            <div id="content" class="col-md-9"> 
            
            <section class="section1"><h1>Introduction to the Module</h1>
<section class="section2"><h2>Module Organisation</h2>
<p>Welcome to <em>MMB8052 - Bioinformatics for Biomedical Scientists</em>. This module is mostly practical in nature - 10 computer lab sessions will introduce you to the fundamental computing tools used throughout much of modern bioinformatics, and will also provide case studies of the "read world" use of these tools. The lectures in the module will be delivered by a range of scientists from across the Faculty of Medical Sciences, and will highlight the <em>application</em> of bioinformatics in modern biomedical research.</p>
</section><section class="section2"><h2>Module Assessment</h2>
<p>Due to the practical emphasis of the module, the assessment will also focus on these practical aspects. The module is assessed through two exercises - one short answer quiz in which the solutions to the posed problems should be derived computationally (more on this later). The second assessment will be a lab report style write-up of the application of some of the tools you will learn how to use in the practicals. Assessment 1 is worth 25% of the module mark. Assessment 2 makes up the remaining 75%.</p>
<p>In addition to these assessed, summative exercises, there will also be a range of formative tests throughout the module. These will mostly take the form of multiple choice quizzes, integrated into the practical sessions or provided separately on Canvas. While these components are not assessed, or compulsory to complete, they will aid and reinforce your understanding of the material presented.</p>
</section><section class="section2"><h2>About This Handbook</h2>
<p>The practical sessions will each be accompanied by a handbook like this one. These handbooks will provide you with a lot of background information relevant to the practical at hand, and will provide you with walk-through instructions for what you are supposed to do in each session. Computer code (usually intended to be typed in to the appropriate computational interface - we'll get to what this means later) will be presented in chunks styled like this:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># these are some command line instructions:</span>
$ <span class="nb">pwd</span>
/home/student
$ ls -l -h ~
</code></pre></div>
<p>The <code>$</code> sign is used to represent the beginning of each command, but <em><strong>should not be typed</strong></em>.</p>
<p>Exercises, which will direct you to accomplish some computational task, will be presented like this:</p>
<section class="exercise section3"><h3>Example Exercise</h3>
<p>Estimated time: 0 mins                                         </p>
<p>The instructions to follow will be in this block of text.</p>
<ul>
<li>First instruction</li>
<li>Second instruction</li>
<li>etc.</li>
</ul>
</section></section></section><section class="section1"><h1>Linux</h1>
<p>Linux is an umbrella term which describes a family of open-source, "Unix-like" computer operating systems which are based on the Linux kernel. The first Linux operating systems were released in the mid-90s and today they are used throughout computing, particularly in the infrastructure which runs the World-Wide Web, and in scientific computing and virtually all supercomputers. The Android smartphone operating system is a Linux system. Popular Linux distributions include:</p>
<ul>
<li><a href="https://ubuntu.com/">Ubuntu</a></li>
<li><a href="https://getfedora.org/">Fedora</a></li>
<li><a href="https://www.debian.org/">Debian</a></li>
<li><a href="https://mxlinux.org/">MX Linux</a></li>
</ul>
<section class="section2"><h2>The Kernel</h2>
<p>A kernel is the computer program at the heart of an operating system (OS), and is responsible for the control of everything in the system. The kernel facilitates interactions between hardware and software (via <em>drivers</em>) and optimises the use of system resources such as CPU time and RAM usage. The main kernels in use in modern computing are the Linux kernel, the Windows NT kernel and the MacOS kernel. All of the Linux distributions listed above use the same kernel at their core.</p>
</section><section class="section2"><h2>Unix</h2>
<p>The Unix operating system is ancient, in computing terms. It was conceived and implemented in 1969 at AT&amp;T's Bell Labs. It is modular by design, with a number of robust tools each designed to perform a limited, well-defined function. A program, known as the Unix <em>shell</em> provides a text-based interface to these tools, and allows the user to combine them in order to perform complex workflows. Thanks to its efficient and robust nature, this computing paradigm persists today in the modern, Unix-like operating systems, Linux and MacOS.</p>
<blockquote>
<p>This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p>
<p>-- Doug McIlory (Bell Labs)</p>
</blockquote>
</section><section class="section2"><h2>The Shell</h2>
<p>A Unix shell is a command-line user interface for Unix-like operating systems. It provides a programmable environment for controlling the OS, and running executable programs. It is typical for the user of a Unix-like OS to interact with the shell via a <em>terminal emulator</em> - a program which simulates the features of a hardware video terminal interface. Feature-rich terminal emulators are available for all modern operating systems.</p>
<p>There are many different shell programs, all of which have different features. The shells you will encounter most often are bash (the "Bourne-Again Shell") which is the default in most major Linux distributions, and zsh (Z Shell) which is the default in MacOS. Zsh is backwards compatible with bash (so any code written for bash will work in zsh, but not necessarily vice versa).</p>
</section><section class="section2"><h2>Logging in to a Linux Server</h2>
<p>Rather than install Linux directly onto your desktops, we will use a terminal emulation program to log into a virtual cloud server which has been configured for these practicals. It should be noted that you'll be using your computer as a dumb terminal (client) that will display the information generated by programs running on the cloud VM (this is an example of a <em>client-server</em> model).</p>
<p>You should have received an email from Microsoft Azure, inviting you to register for the lab - click the 'Register for the lab' button in the email, and log in to Azure Labs with your University credentials.</p>
<p>Once logged in, you should see a heading 'My virtual machines', with a single entry underneath. Click the slider in the bottom-left of the VM box to power the machine on. Once it's started up (this will take a couple of minutes), click the icon in the bottom-right of the VM box which looks like a small grey monitor. Pick 'Connect via SSH' from the menu which appears, and set your password when prompted. Once the password has been set (again, this takes a couple of minutes) select 'Connect via SSH' again, copy the text in the popup box which appears - this is your SSH invocation to log in to your VM. For example:</p>
<div class="highlight"><pre><span></span><code>ssh -p <span class="m">65432</span> student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com
</code></pre></div>
<section class="section3"><h3>Logging in from Windows</h3>
</section><section class="exercise section3"><h3>Exercise 1.1(a)</h3>
<p>Estimated time: 2 mins</p>
<ul>
<li>Go to: <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</a></li>
<li>You'll need <strong>putty.exe</strong> and <strong>psftp.exe</strong></li>
<li>Run <strong>putty.exe</strong> to open the PuTTY configuration screen</li>
<li>In the "Host name (or IP address)" box, type: <strong>USERNAME@LAB.ADDRESS</strong>, replacing this with the connection string which is shown when you click - from the example above:</li>
</ul>
<div class="highlight"><pre><span></span><code>student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com
</code></pre></div>
<ul>
<li>In the "Port" box, type the number given in the <code>-p</code> argument of your SSH invocation (this is likely to be a large number, greater than 50000 - from the example above <code>65432</code>)</li>
</ul>
<p>PuTTY will then open and prompt you for a password. Enter the password you set when starting your VM for the first time.</p>
</section><section class="section3"><h3>Logging in from MacOS</h3>
</section><section class="exercise section3"><h3>Exercise 1.1(b)</h3>
<p>Estimated time: 2 mins</p>
<ul>
<li>Open 'Terminal.app' (located in /Applications/Utilities/Terminal.app).</li>
<li>Paste in the connection string shown when you click 'Connect via SSH' on the Azure Lab (above). As per the example above:</li>
</ul>
<div class="highlight"><pre><span></span><code>ssh -p <span class="m">65432</span> student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com
</code></pre></div>
<ul>
<li>Enter your password when prompted.</li>
</ul>
</section><section class="section3"><h3>Running Commands</h3>
<p>Once you have logged in, you should see what's known as a "command prompt" - it is here that you can type commands to be interpreted by the active Unix shell (on our VMs, the default shell is bash). You should see something like this in your terminal:</p>
<div class="highlight"><pre><span></span><code>Welcome to Ubuntu 18.04.6 LTS (GNU/Linux 5.4.0-1069-azure x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Tue Jun  7 15:37:31 UTC 2022

  System load:  1.18               Processes:           144
  Usage of /:   46.8% of 28.90GB   Users logged in:     0
  Memory usage: 7%                 IP address for eth0: 10.210.28.5
  Swap usage:   0%

Last login: Fri Feb 11 11:47:23 2022 from 128.240.225.23
student@ML-RefVm-558285:~$
</code></pre></div>
<p>The bulk of this is information about the state and health of the system, produced by the OS on login. The final line contains 3 key elements:</p>
<ol>
<li><code>student@ML-RefVm-558285</code> is your username (<code>student</code>) at the name of the computer (<code>ML-RefVm-558285</code>)</li>
<li><code>~</code> denotes your <em>current working directory</em> - more on this below - this tilde character is a widely used shorthand for the <em>home</em> directory.</li>
<li>The <code>$</code> symbol is the prompt, and will be used throughout these practicals to indicate the beginning of a bash command (you shouldn't type the <code>$</code>).</li>
</ol>
</section><section class="exercise section3"><h3>Exercise 1.2</h3>
<p>Estimated time: 2 mins</p>
<p>Try typing the following commands:</p>
<div class="highlight"><pre><span></span><code>$ ls
$ touch emptyfile
$ ls
</code></pre></div>
<ul>
<li>What do you see after each command?</li>
<li>Can you work out what the <code>ls</code> and <code>touch</code> commands are doing?                                        |</li>
</ul>
</section><section class="section3"><h3>Command Anatomy</h3>
<p>The commands you can issue at this prompt are many and varied, but all share a common anatomy. This anatomy is illustrated in figure 1. They begin with the name of the executable command, then are followed by options (or flags), then finally come the arguments (or parameters). Options and arguments change the behaviour of the command in certain prescribed ways.</p>
<table>
<thead>
<tr>
<th align="center"><figure class="figure1" data-title="Figure 1: The common anatomy of a Linux command"><img alt="Figure 1: The common anatomy of a Linux command" src="images/anatomy.png"/></figure></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><b>Figure 1: The common anatomy of a Linux command</b></td>
</tr>
</tbody>
</table>
<p>The whitespace in the command can be just as important as the rest of the text - it is itself interpreted by the shell in specific ways, and the presence (or absence) of a space at a particular place in the command can completely change how it is interpreted. It's also worth mentioning at this point that bash is <strong>case sensitive</strong>.</p>
<p>We'll look in more detail at what the commands in exercise 2 (and many others) are for later on in the practical. For now, we have another important feature of Linux to introduce.</p>
</section></section></section><section class="section1"><h1>The Linux File System</h1>
<p>Modern operating systems appeal to a broad user base by layering abstractions on top of hidden complexity. The graphical interface to the file system ("Explorer" in Windows and "Finder" in MacOS) is one such abstraction. By making it convenient to search and browse for files, and providing easy access to commonly-used areas of the file system (Documents, Downloads etc) the user doesn't need to put much thought in to where files are actually stored.</p>
<p>Command line Linux does not offer these abstractions. Consequently, the onus is on the user to understand the topology of the file system, since otherwise things can get in a real mess - particularly because tracking down files if you don't know where they have gone can be difficult.</p>
<section class="section2"><h2>File System Layout</h2>
<p>For convenience, the Linux file system is usually thought of as having a tree-like structure (or a <em>hierarchy</em>). Everything in this hierarchy is a file, although some have special properties - for example a <em>directory</em> is a file which acts as a container for other files (some of which may themselves be directories). This tree has a <em>root</em> - indicated by a forward slash (<code>/</code>). This is a directory which contains all of the other directories and files in the file system.</p>
<p>A <em>path</em> describes a file system location as a string of characters, with each path component separated by a delimiting character. In Linux, the delimiting character is the forward slash (<code>/</code>). In the example in figure 2, the highlighted path is <code>/home/user1/Project1/results/mapping.bam</code>. This path uniquely identifies the location of the <code>mapping.bam</code> file in the file system. We can have other files named <code>mapping.bam</code>, but they will have their own path.</p>
<table>
<thead>
<tr>
<th align="center"><figure class="figure2" data-title="Figure 2: A typical Linux file system hierarchy"><img alt="Figure 2: A typical Linux file system hierarchy" src="images/filesystem.png"/></figure></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><b>Figure 2: A typical Linux file system hierarchy</b></td>
</tr>
</tbody>
</table>
</section><section class="section2"><h2>Navigating the file system</h2>
<p>When you log in to a Linux system (as in exercise 1, above), your shell places you in a particular directory, from which the commands you issue will be run. By default this location is your individual <em>home</em> directory - <code>/home/username</code> (where <code>username</code> is replaced by your username on the system you're using). Knowing this location (also known as your <em>current working directory</em>) is important because the commands you issue will run relative to this location. To explain further, consider the following:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># list the contents of the current working directory</span>
$ ls
<span class="c1"># list the contents of your home directory</span>
$ ls /home/username
</code></pre></div>
<p>At login, these two commands are effectively equivalent, as your current working directory <em>is</em> your home directory. As soon as you change your current working directory, which you can do by using the command <code>cd</code>, the results of these two commands will diverge.</p>
<p>On the VM you are using, your current working directory is shown before the prompt (when you login you will see a tilde (<code>~</code>) before the <code>$</code> - this is a shorthand for home). If you want to find it explicitly, the command <code>pwd</code> prints your current working directory.</p>
<section class="exercise section3"><h3>Exercise 1.3</h3>
<p>Estimated time: 5 mins</p>
<p>Run the commands listed below:</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">pwd</span>
$ <span class="nb">cd</span> ..
$ <span class="nb">pwd</span>
$ <span class="nb">cd</span> /
$ <span class="nb">pwd</span>
$ ls
$ <span class="nb">cd</span>
$ <span class="nb">pwd</span>
</code></pre></div>
<p>Some things to consider:</p>
<ul>
<li>Does the output of <code>pwd</code> match the text in front of the prompt?</li>
<li>Can you work out what <code>cd ..</code> does?</li>
<li>How does the output of <code>ls</code> compare to the directories shown in figure 2?</li>
<li>What does the third <code>cd</code> command do?</li>
</ul>
</section></section><section class="section2"><h2>Absolute and relative paths</h2>
<p>File system locations in Linux can be described in two ways:</p>
<ol>
<li>As a full path all the way to the root of the file system - this is known as an <strong>absolute file path</strong></li>
<li>In relation to the current working directory - this is known as a <strong>relative file path</strong></li>
</ol>
<p>Absolute (or fully qualified) file paths always begin with a <code>/</code> forward slash. Relative file paths do not.</p>
<p>Consider the file hierarchy shown in figure 2 again. For <code>user1</code> at login (so therefore with <code>/home/user1</code> as the current working directory), the following are true:</p>
<ul>
<li>The <em>relative</em> path to the highlighted <code>mapping.bam</code> file is <code>Project1/results/mapping.bam</code>. Note the lack of a forward slash at the beginning of the path.</li>
<li>The <em>absolute</em> path to this file is <code>/home/user1/Project1/results/mapping.bam</code>. This time there is a forward slash at the beginning - showing that the path takes us back to the root.</li>
<li>The absolute path of the <code>ls</code> executable is <code>/bin/ls</code>. Try typing this fully qualified path at the command line.</li>
<li>The relative path to this file is more complicated, since we need to navigate "up" the tree before going back down: <code>../../bin/ls</code>. The double dot notation means to look in the parent directory, so <code>../..</code> is the parent of the parent (in this case, the root directory - the parent directory of <code>/home/user1</code> is <code>/home</code>, and the parent of <code>/home</code> is <code>/</code>).</li>
</ul>
<p>Absolute file paths are always unambiguous addresses of a single file on the file system. Relative file paths have some inherent ambiguity, as the file they point to can differ depending on your current working directory. For example, <code>mapping.bam</code> may be a common output of running a command, so therefore you may have a <code>mapping.bam</code> file in lots of different projects, where the distinguishing feature is not the name of the file, but the name of a parent directory that defines that project. Running a command which points to <code>results/mapping.bam</code> (a relative path) will have a different effect depending on whether you run it from <code>~/Project1</code> or <code>~/Project2</code>.</p>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Summary</strong></th>
<th><strong>Behaviour with no arguments</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls</code></td>
<td>List directory contents</td>
<td>List the contents of the current working directory</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>Change working directory</td>
<td>Change to the home directory</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>Print working directory</td>
<td>No common arguments</td>
</tr>
</tbody>
</table>
<p>Table 1: Commands for navigating the Linux file system.</p>
</section><section class="section2"><h2>File manipulation</h2>
<p>Now we understand something of the layout of the file system, and how to navigate it we can begin to learn how to manipulate files. For this we will introduce 6 new commands:</p>
<ul>
<li><code>echo</code> - "repeats" what follows the command in the terminal.</li>
<li><code>nano</code> - a simple command-line text editor.</li>
<li><code>cp</code> - copies a file.</li>
<li><code>mv</code> - moves a file.</li>
<li><code>mkdir</code> - makes (mk) a new directory (dir).</li>
<li><code>rm</code> - removes a file.</li>
</ul>
<p>Before we start to look at these commands, we have to learn something about output streams and redirection.</p>
<section class="section3"><h3>Output Streams</h3>
<p>Many command line programs produce output in the terminal. We've already seen a couple of examples of this - <code>ls</code> prints its list of files in the terminal, for instance. There are actually two streams of output which a program can use to produce this effect - these are known as <code>STDOUT</code> (standard output) and <code>STDERR</code> (standard error). Conventionally, <code>STDOUT</code> is used for the results of the program, and <code>STDERR</code> is reserved for error messages.</p>
<p>We can take advantage of a feature of bash known as <em>output redirection</em> to manipulate the destination of this output - making it possible to store it in a file instead of printing it to the screen. It is even possible to use the output of one command as the <em>input</em> for a subsequent command.</p>
<p>Useful redirection commands:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># redirect the output of **command** to **file** - if file already exists, it will be over-written.</span>
$ <span class="nb">command</span> &gt; file
<span class="c1"># append the output of **command** to **file** - if file already exists, the output will be added to the end.</span>
$ <span class="nb">command</span> &gt;&gt; file
<span class="c1"># the input of **command** will be read from **file**</span>
$ <span class="nb">command</span> &lt; file
<span class="c1"># the output of **command1** will be used as the input for **command2**</span>
$ command1 <span class="p">|</span> command2
</code></pre></div>
<p>All of the redirection commands above work with <code>STDOUT</code>. <code>STDERR</code> will still end up being printed in the terminal. It is also possible to redirect <code>STDERR</code>, though not necessary for anything we're attempting to accomplish on this course.</p>
<p>We can make use of output redirection to create a file, since the <code>&gt;</code> and <code>&gt;&gt;</code> operators will create a file if it does not already exist.</p>
</section><section class="exercise section3"><h3>Exercise 1.4</h3>
<p>Estimated time: 5 - 10 mins</p>
<p>Run the commands listed below:</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">"Hello, World"</span>
$ <span class="nb">echo</span> <span class="s2">"Hello, World"</span> &gt; ~/myfile.txt
$ ls ~
$ nano ~/myfile.txt
</code></pre></div>
<p>Take some time to investigate how <code>nano</code> works - there are some instructions on screen when it opens.</p>
<p>Can you figure out how to change the file contents, how to save, and how to exit?</p>
<p>Some other things to consider:</p>
<ul>
<li>What does the <code>echo</code> command do?</li>
<li>How does the addition of <code>&gt; ~/myfile.txt</code> change the behaviour of the <code>echo</code> command?</li>
<li>Is <code>~/myfile.txt</code> a relative or absolute path?</li>
<li>What does <code>^</code> mean in the on-screen help for <code>nano</code>?</li>
<li>Can you figure out how to use <code>echo</code> and <code>&gt;&gt;</code> to add extra content to the file?</li>
</ul>
</section><section class="section3"><h3>Copying and Moving files</h3>
<p><code>cp</code> and <code>mv</code> are the Unix commands for copying and moving files, respectively. In both cases they take two compulsory arguments - (1) the name of the file to act on, and (2) the destination location that you want it to end up. As the names suggest, after using <code>cp</code> you will have 2 copies of the file (the original and a copy at the destination), after using <code>mv</code> you will still only have one copy (the one at the destination location - the original will be removed). The destination file location can be in the same directory as the original file, but must have a different name, or it could be in a different directory - in this case the filename can remain the same.</p>
<div class="highlight"><pre><span></span><code>$ ls
emptyfile myfile.txt
<span class="c1"># copy myfile.txt (.bak is a Unix convention for a backup copy)</span>
$ cp myfile.txt myfile.bak
$ ls
emptyfile myfile.bak  myfile.txt
<span class="c1"># rename the new file</span>
$ mv myfile.bak mf.b
$ ls
emptyfile mf.b  myfile.txt
</code></pre></div>
</section><section class="section3"><h3>Working with Directories</h3>
<p>Directories are directly analogous to <em>folders</em> in Windows and MacOS. As described previously, they are special files which are capable of containing other files (and indeed other directories). Sensible and well-planned use of directories can impose a logical organisational structure on your filesystem. The command for creating new directories is <code>mkdir</code> (for <strong>m</strong>a<strong>k</strong>e <strong>dir</strong>ectory) - like many other tools we've looked at so far, the simplest mode of operation for <code>mkdir</code> is to provide it with a single argument - the name of the directory you want to create.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># make a new directory called **mydir** in the current working directory</span>
$ mkdir mydir
$ ls
emptyfile   mydir/  mf.b   myfile.txt
</code></pre></div>
<strong>Note</strong></p>
<p>The syntax highlighting I use here cannot replicate the colours you will see in your terminal (where directories will be coloured in blue). I've addressed this by listing directories with a trailing slash. You can replicate this by adding the <code>-p</code> option to <code>ls</code> - the exact results seen in the block above can be obtained with: <code>ls --color=never -p</code></p>
<p>Other commands already introduced work with directories too - <code>mv</code> will move a directory (and its contents) just like any other file. It is possible to copy whole directories with <code>cp</code> as well, although you do have to add the <code>-r</code> option for this to work correctly:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># move file in to new directory</span>
$ mv mf.b mydir
<span class="c1"># move the directory and its contents</span>
$ mv mydir mynewdir
$ ls
emptyfile myfile.txt  mynewdir/
$ ls mynewdir
mf.b
<span class="c1"># copy the directory and its contents</span>
$ cp -r mynewdir mycpdir
$ ls
emptyfile mycpdir/  myfile.txt  mynewdir/
$ ls mycpdir
mf.b
</code></pre></div>
</section><section class="section3"><h3>Deleting Files</h3>
<p>All the commands we've looked at so far create files (and directories), however, sometimes it is necessary to delete things too. The command for removing files is <code>rm</code> amd again, the simplest way of using it is with a single argument - the file to be deleted.</p>
<p>Unlike the operating systems you may be used to, there is no request for confirmation when you issue the <code>rm</code> command - the file will be immediately removed from the file system (it also doesn't go into any sort of recoverable "Trash" folder). For this reason, <code>rm</code> should be treated with caution - especially when used with the <code>-r</code> option (which like <code>cp</code> is used to "recursively" act on all the files in a directory, including the directory itself). If you do want to be prompted for confirmation before deleting a file, you can add the <code>-i</code> option to your <code>rm</code> command.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># remove a file</span>
$ rm emptyfile
<span class="c1"># remove a directory (and contents)</span>
$ rm -r mycpdir
$ ls
myfile.txt  mynewdir/
<span class="c1"># remove a file and prompt for confirmation</span>
$ rm -i myfile.txt
rm: remove regular file <span class="s1">'myfile.txt'</span>? n
$ ls
myfile.txt  mynewdir/
</code></pre></div>
</section><section class="exercise section3"><h3>Exercise 1.5</h3>
<p>Estimated time: 5 - 10 mins</p>
<p>Run the commands listed below, use <code>ls</code> to keep track of your files throughout:</p>
<div class="highlight"><pre><span></span><code>$ mkdir ~/mydir
$ cp ~/myfile.txt ~/mydir
$ cat ~/mydir/myfile.txt
$ mkdir -p ~/level1/level2
$ touch ~/level1/level2/myfile.txt
$ mv ~/level1/level2/myfile.txt ~/mydir
$ cat ~/mydir/myfile.txt
$ rm -r ~/level1
</code></pre></div>
<p>Quick quiz:</p>
<ul>
<li>There's a new command in here (<code>cat</code>) - can you work out what it does?</li>
<li>What happens to the file <code>~/mydir/myfile.txt</code> between the two times you run <code>cat</code> on it?</li>
<li>What does the <code>-p</code> option do to the behaviour of <code>mkdir</code>?</li>
<li>What happens if you run command 4 without this option?</li>
<li>What is the effect of the final command on <code>~/level1/level2</code>?</li>
</ul>
</section></section></section><section class="section1"><h1>Getting Help</h1>
<p>You will have realised by now that the catalogue of Unix commands is very large, and each individual command comes with an array of options and arguments to modify the default behaviour. This means that, especially for the beginner, command line computing can quickly become overwhelming. Fortunately, it is not necessary (nor is it possible) to remember all of the commands and their available options. Linux has an extensive built-in help system to assist you with navigating this bewildering complexity, <code>man</code> (short for Manual).</p>
<div class="highlight"><pre><span></span><code><span class="c1"># get help on the ls command</span>
$ man ls
</code></pre></div>
<p>This command will display the <code>man</code> page for the <code>ls</code> command. Linux manual pages follow a common structure, which should make it easy to track down the information you require, once you know how to navigate them.</p>
<table>
<thead>
<tr>
<th><strong>Section</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>Name of the command</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>General usage parameters of the command</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>Describes what the command does</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>Describes all of the arguments or options of the command</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>Lists other commands that are directly related to the command in the man page or closely resemble its functionality</td>
</tr>
<tr>
<td>BUGS</td>
<td>Explains any known issues or bugs that exist with the command or its output</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>Common usage examples that give the reader an idea of how the command can be used</td>
</tr>
<tr>
<td>AUTHORS</td>
<td>The author of the man page/command</td>
</tr>
</tbody>
</table>
</section>
            </div>
        </div>
    </div>

        </main>
		
		<footer class="text-muted">
	<hr>
	<div class="container">
		<div class="float-right">
			<ul style="list-style: none">
			<li><a href="#">Back to top</a></li>
			
			
			<li><a href="mmb8052__practical_1.pdf" target="_blank"><i class="fa fa-file-pdf-o"></i>&nbsp;Download as PDF</a></li>
			
			</ul>
		</div>
		<p>Generated using <a target="_blank" href="https://github.com/chirun-ncl/chirun">Chirun</a>, written by the E-Learning Unit, School of Mathematics &amp; Statistics, Newcastle University</p>
		<p>This page last generated: 2022-06-22</p>
	</div>
</footer>
		
    </body>
</html>
