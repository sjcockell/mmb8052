<h1 id="introduction-to-the-module">Introduction to the Module</h1>
<h2 id="module-organisation">Module Organisation</h2>
<p>Welcome to <em>MMB8052 - Bioinformatics for Biomedical Scientists</em>. This module is mostly practical in nature - 10 computer lab sessions will introduce you to the fundamental computing tools used throughout much of modern bioinformatics, and will also provide case studies of the “read world” use of these tools. The lectures in the module will be delivered by a range of scientists from across the Faculty of Medical Sciences, and will highlight the <em>application</em> of bioinformatics in modern biomedical research.</p>
<h2 id="module-assessment">Module Assessment</h2>
<p>Due to the practical emphasis of the module, the assessment will also focus on these practical aspects. The module is assessed through two exercises - one short answer quiz in which the solutions to the posed problems should be derived computationally (more on this later). The second assessment will be a lab report style write-up of the application of some of the tools you will learn how to use in the practicals. Assessment 1 is worth 25% of the module mark. Assessment 2 makes up the remaining 75%.</p>
<p>In addition to these assessed, summative exercises, there will also be a range of formative tests throughout the module. These will mostly take the form of multiple choice quizzes, integrated into the practical sessions or provided separately on Canvas. While these components are not assessed, or compulsory to complete, they will aid and reinforce your understanding of the material presented.</p>
<h2 id="about-this-handbook">About This Handbook</h2>
<p>The practical sessions will each be accompanied by a handbook like this one. These handbooks will provide you with a lot of background information relevant to the practical at hand, and will provide you with walk-through instructions for what you are supposed to do in each session. Computer code (usually intended to be typed in to the appropriate computational interface - we’ll get to what this means later) will be presented in chunks styled like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># these are some command line instructions:</span></a>
<a class="sourceLine" id="cb1-2" title="2">$ <span class="bu">pwd</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ex">/home/student</span></a>
<a class="sourceLine" id="cb1-4" title="4">$ <span class="fu">ls</span> -l -h ~</a></code></pre></div>
<p>If you see this character: in one of these listings, it means that the command should be entered on one line (the line has been broken in the listing for presentation reasons only). The <code>$</code> sign is used to represent the beginning of each command, but <em><strong>should not be typed</strong></em>.</p>
<p>Exercises, which will direct you to accomplish some computational task, will be presented like this:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 0 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise X</strong></p>
<p>The instructions to follow will be in this block of text.</p>
<ul>
<li>First instruction</li>
<li>Second instruction</li>
<li>etc.</li>
</ul></td>
</tr>
</tbody>
</table>
<h1 id="linux">Linux</h1>
<p>Linux is an umbrella term which describes a family of open-source, “Unix-like” computer operating systems which are based on the Linux kernel. The first Linux operating systems were released in the mid-90s and today they are used throughout computing, particularly in the infrastructure which runs the World-Wide Web, and in scientific computing and virtually all supercomputers. The Android smartphone operating system is a Linux system. Popular Linux distributions include:</p>
<ul>
<li><a href="https://ubuntu.com/">Ubuntu</a></li>
<li><a href="https://getfedora.org/">Fedora</a></li>
<li><a href="https://www.debian.org/">Debian</a></li>
<li><a href="https://mxlinux.org/">MX Linux</a></li>
</ul>
<h2 id="the-kernel">The Kernel</h2>
<p>A kernel is the computer program at the heart of an operating system (OS), and is responsible for the control of everything in the system. The kernel facilitates interactions between hardware and software (via <em>drivers</em>) and optimises the use of system resources such as CPU time and RAM usage. The main kernels in use in modern computing are the Linux kernel, the Windows NT kernel and the MacOS kernel. All of the Linux distributions listed above use the same kernel at their core.</p>
<h2 id="unix">Unix</h2>
<p>The Unix operating system is ancient, in computing terms. It was conceived and implemented in 1969 at AT&amp;T’s Bell Labs. It is modular by design, with a number of robust tools each designed to perform a limited, well-defined function. A program, known as the Unix <em>shell</em> provides a text-based interface to these tools, and allows the user to combine them in order to perform complex workflows. Thanks to its efficient and robust nature, this computing paradigm persists today in the modern, Unix-like operating systems, Linux and MacOS.</p>
<p> </p>
<blockquote>
<p>This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p>
<p>– Doug McIlory (Bell Labs)</p>
</blockquote>
<h2 id="the-shell">The Shell</h2>
<p>A Unix shell is a command-line user interface for Unix-like operating systems. It provides a programmable environment for controlling the OS, and running executable programs. It is typical for the user of a Unix-like OS to interact with the shell via a <em>terminal emulator</em> - a program which simulates the features of a hardware video terminal interface. Feature-rich terminal emulators are available for all modern operating systems.</p>
<p>There are many different shell programs, all of which have different features. The shells you will encounter most often are bash (the “Bourne-Again Shell”) which is the default in most major Linux distributions, and zsh (Z Shell) which is the default in MacOS. Zsh is backwards compatible with bash (so any code written for bash will work in zsh, but not necessarily vice versa).</p>
<h2 id="logging-in-to-a-linux-server">Logging in to a Linux Server</h2>
<p>Rather than install Linux directly onto your desktops, we will use a terminal emulation program to log into a virtual cloud server which has been configured for these practicals. It should be noted that you’ll be using your computer as a dumb terminal (client) that will display the information generated by programs running on the cloud VM (this is an example of a <em>client-server</em> model).</p>
<p>You should have received an email from Microsoft Azure, inviting you to register for the lab - click the ‘Register for the lab’ button in the email, and log in to Azure Labs with your University credentials.</p>
<p>Once logged in, you should see a heading ‘My virtual machines’, with a single entry underneath. Click the slider in the bottom-left of the VM box to power the machine on. Once it’s started up (this will take a couple of minutes), click the icon in the bottom-right of the VM box which looks like a small grey monitor. Pick ‘Connect via SSH’ from the menu which appears, and set your password when prompted. Once the password has been set (again, this takes a couple of minutes) select ‘Connect via SSH’ again, copy the text in the popup box which appears - this is your SSH invocation to log in to your VM. For example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">ssh</span> -p 65432 student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com</a></code></pre></div>
<h3 id="logging-in-from-windows">Logging in from Windows</h3>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 2 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise 1a</strong></p>
<ul>
<li>Go to: <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" class="uri">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</a></li>
<li>You’ll need <strong>putty.exe</strong> and <strong>psftp.exe</strong></li>
<li>Run <strong>putty.exe</strong> to open the PuTTY configuration screen</li>
<li>In the “Host name (or IP address)” box, type: <strong>USERNAME@LAB.ADDRESS</strong>, replacing this with the connection string which is shown when you click - from the example above:</li>
</ul>
<pre><code>student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com</code></pre>
<ul>
<li>In the “Port” box, type the number given in the <code>-p</code> argument of your SSH invocation (this is likely to be a large number, greater than 60000 - from the example above <code>65432</code>)</li>
</ul>
<p>PuTTY will then open and prompt you for a password. Enter the password you set when starting your VM for the first time.</p></td>
</tr>
</tbody>
</table>
<h3 id="logging-in-from-macos">Logging in from MacOS</h3>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 2 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise 1b</strong></p>
<ul>
<li>Open ‘Terminal.app’ (located in /Applications/Utilities/Terminal.app).</li>
<li>Paste in the connection string shown when you click ‘Connect via SSH’ on the Azure Lab (above). As per the example above:</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">ssh</span> -p 65432 student@ml-lab-77568ef7-c936-416a-a101-5e2874043ea1.uksouth.cloudapp.azure.com</a></code></pre></div>
<ul>
<li>Enter your password when prompted.</li>
</ul></td>
</tr>
</tbody>
</table>
<h3 id="running-commands">Running Commands</h3>
<p>Once you have logged in, you should see what’s known as a “command prompt” - it is here that you can type commands to be interpreted by the active Unix shell (on our VMs, the default shell is bash). You should see something like this in your terminal:</p>
<pre><code>Welcome to Ubuntu 18.04.6 LTS (GNU/Linux 5.4.0-1069-azure x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Tue Jun  7 15:37:31 UTC 2022

  System load:  1.18               Processes:           144
  Usage of /:   46.8% of 28.90GB   Users logged in:     0
  Memory usage: 7%                 IP address for eth0: 10.210.28.5
  Swap usage:   0%

Last login: Fri Feb 11 11:47:23 2022 from 128.240.225.23
student@ML-RefVm-558285:~$</code></pre>
<p>The bulk of this is information about the state and health of the system, produced by the OS on login. The final line contains 3 key elements:</p>
<ol type="1">
<li><code>student@ML-RefVm-558285</code> is your username (<code>student</code>) at the name of the computer (<code>ML-RefVm-558285</code>)</li>
<li><code>~</code> denotes your <em>current working directory</em> - more on this below - this tilde character is a widely used shorthand for the <em>home</em> directory.</li>
<li>The <code>$</code> symbol is the prompt, and will be used throughout these practicals to indicate the beginning of a bash command (you shouldn’t type the <code>$</code>).</li>
</ol>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 2 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise 2</strong></p>
<p>Try typing the following commands:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb6-2" title="2">$ <span class="fu">touch</span> emptyfile</a>
<a class="sourceLine" id="cb6-3" title="3">$ <span class="fu">ls</span></a></code></pre></div>
<ul>
<li>What do you see after each command?</li>
<li>Can you work out what the <code>ls</code> and <code>touch</code> commands are doing?</li>
</ul></td>
</tr>
</tbody>
</table>
<p>The commands you can issue at this prompt are many and varied, but all share a common anatomy. This anatomy is illustrated in figure 1. They begin with the name of the executable command, then are followed by options (or flags), then finally come the arguments (or parameters). Options and arguments change the behaviour of the command in certain prescribed ways.</p>
<figure>
<img src="media/anatomy.png" alt="the common anatomy of a Linux command" /><figcaption>the common anatomy of a Linux command</figcaption>
</figure>
<p>The whitespace in the command can be just as important as the rest of the text - it is itself interpreted by the shell in specific ways, and the presence (or absence) of a space at a particular place in the command can completely change how it is interpreted. It’s also worth mentioning at this point that bash is <strong>case sensitive</strong>.</p>
<p>We’ll look in more detail at what the commands in exercise 2 (and many others) are for later on in the practical. For now, we have another important feature of Linux to introduce.</p>
<h1 id="the-linux-file-system">The Linux File System</h1>
<p>Modern operating systems appeal to a broad user base by layering abstractions on top of hidden complexity. The graphical interface to the file system (“Explorer” in Windows and “Finder” in MacOS) is one such abstraction. By making it convenient to search and browse for files, and providing easy access to commonly-used areas of the file system (Documents, Downloads etc) the user doesn’t need to put much thought in to where files are actually stored.</p>
<p>Command line Linux does not offer these abstractions. Consequently, the onus is on the user to understand the topology of the file system, since otherwise things can get in a real mess - particularly because tracking down files if you don’t know where they have gone can be difficult.</p>
<h2 id="file-system-layout">File System Layout</h2>
<p>For convenience, the Linux file system is usually thought of as having a tree-like structure (or a <em>hierarchy</em>). Everything in this hierarchy is a file, although some have special properties - for example a <em>directory</em> is a file which acts as a container for other files (some of which may themselves be directories). This tree has a <em>root</em> - indicated by a forward slash (<code>/</code>). This is a directory which contains all of the other directories and files in the file system.</p>
<p>A <em>path</em> describes a file system location as a string of characters, with each path component separated by a delimiting character. In Linux, the delimiting character is the forward slash (<code>/</code>). In the example in figure 2, the highlighted path is <code>/home/user1/Project1/results/mapping.bam</code>. This path uniquely identifies the location of the <code>mapping.bam</code> file in the file system. We can have other files named <code>mapping.bam</code>, but they will have their own path.</p>
<figure>
<img src="media/filesystem.png" alt="Figure 2: A typical Linux file system hierarchy" /><figcaption>Figure 2: A typical Linux file system hierarchy</figcaption>
</figure>
<h2 id="navigating-the-file-system">Navigating the file system</h2>
<p>When you log in to a Linux system (as in exercise 1, above), your shell places you in a particular directory, from which the commands you issue will be run. By default this location is your individual <em>home</em> directory - <code>/home/username</code> (where <code>username</code> is replaced by your username on the system you’re using). Knowing this location (also known as your <em>current working directory</em>) is important because the commands you issue will run relative to this location. To explain further, consider the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># list the contents of the current working directory</span></a>
<a class="sourceLine" id="cb7-2" title="2">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co"># list the contents of your home directory</span></a>
<a class="sourceLine" id="cb7-4" title="4">$ <span class="fu">ls</span> /home/username</a></code></pre></div>
<p>At login, these two commands are effectively equivalent, as your current working directory <em>is</em> your home directory. As soon as you change your current working directory, which you can do by using the command <code>cd</code>, the results of these two commands will diverge.</p>
<p>On the VM you are using, your current working directory is shown before the prompt (when you login you will see a tilde (<code>~</code>) before the <code>$</code> - this is a shorthand for home). If you want to find it explicitly, the command <code>pwd</code> prints your current working directory.</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 5 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise 3</strong></p>
<p>Run the commands listed below:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="bu">pwd</span></a>
<a class="sourceLine" id="cb8-2" title="2">$ <span class="bu">cd</span> ..</a>
<a class="sourceLine" id="cb8-3" title="3">$ <span class="bu">pwd</span></a>
<a class="sourceLine" id="cb8-4" title="4">$ <span class="bu">cd</span> /</a>
<a class="sourceLine" id="cb8-5" title="5">$ <span class="bu">pwd</span></a>
<a class="sourceLine" id="cb8-6" title="6">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb8-7" title="7">$ <span class="bu">cd</span></a>
<a class="sourceLine" id="cb8-8" title="8">$ <span class="bu">pwd</span></a></code></pre></div>
<p>Some things to consider:</p>
<ul>
<li>Does the output of <code>pwd</code> match the text in front of the prompt?</li>
<li>Can you work out what <code>cd ..</code> does?</li>
<li>How does the output of <code>ls</code> compare to the directories shown in figure 2?</li>
<li>What does the third <code>cd</code> command do?</li>
</ul></td>
</tr>
</tbody>
</table>
<h2 id="absolute-and-relative-paths">Absolute and relative paths</h2>
<p>File system locations in Linux can be described in two ways:</p>
<ol type="1">
<li>As a full path all the way to the root of the file system - this is known as an <strong>absolute file path</strong></li>
<li>In relation to the current working directory - this is known as a <strong>relative file path</strong></li>
</ol>
<p>Absolute (or fully qualified) file paths always begin with a <code>/</code> forward slash. Relative file paths do not.</p>
<p>Consider the file hierarchy shown in figure 2 again. For <code>user1</code> at login (so therefore with <code>/home/user1</code> as the current working directory), the following are true:</p>
<ul>
<li>The <em>relative</em> path to the highlighted <code>mapping.bam</code> file is <code>Project1/results/mapping.bam</code>. Note the lack of a forward slash at the beginning of the path.</li>
<li>The <em>absolute</em> path to this file is <code>/home/user1/Project1/results/mapping.bam</code>. This time there is a forward slash at the beginning - showing that the path takes us back to the root.</li>
<li>The absolute path of the <code>ls</code> executable is <code>/bin/ls</code>. Try typing this fully qualified path at the command line.</li>
<li>The relative path to this file is more complicated, since we need to navigate “up” the tree before going back down: <code>../../bin/ls</code>. The double dot notation means to look in the parent directory, so <code>../..</code> is the parent of the parent (in this case, the root directory - the parent directory of <code>/home/user1</code> is <code>/home</code>, and the parent of <code>/home</code> is <code>/</code>).</li>
</ul>
<p>Absolute file paths are always unambiguous addresses of a single file on the file system. Relative file paths have some inherent ambiguity, as the file they point to can differ depending on your current working directory. For example, <code>mapping.bam</code> may be a common output of running a command, so therefore you may have a <code>mapping.bam</code> file in lots of different projects, where the distinguishing feature is not the name of the file, but the name of a parent directory that defines that project. Running a command which points to <code>results/mapping.bam</code> (a relative path) will have a different effect depending on whether you run it from <code>~/Project1</code> or <code>~/Project2</code>.</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 28%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Summary</th>
<th style="text-align: left;">Behaviour with no arguments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ls</code></td>
<td style="text-align: left;">List directory contents</td>
<td style="text-align: left;">List the contents of the current working directory</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cd</code></td>
<td style="text-align: left;">Change working directory</td>
<td style="text-align: left;">Change to the home directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>pwd</code></td>
<td style="text-align: left;">Print working directory</td>
<td style="text-align: left;">No common arguments</td>
</tr>
</tbody>
</table>
<p>Table 1: Commands for navigating the Linux file system.</p>
<h2 id="file-manipulation">File manipulation</h2>
<p>Now we understand something of the layout of the file system, and how to navigate it we can begin to learn how to manipulate files. For this we will introduce 6 new commands:</p>
<ul>
<li><code>echo</code> - “repeats” what follows the command in the terminal.</li>
<li><code>nano</code> - a simple command-line text editor.</li>
<li><code>cp</code> - copies a file.</li>
<li><code>mv</code> - moves a file.</li>
<li><code>mkdir</code> - makes (mk) a new directory (dir).</li>
<li><code>rm</code> - removes a file.</li>
</ul>
<p>Before we start to look at these commands, we have to learn something about output streams and redirection.</p>
<h3 id="output-streams">Output Streams</h3>
<p>Many command line programs produce output in the terminal. We’ve already seen a couple of examples of this - <code>ls</code> prints its list of files in the terminal, for instance. There are actually two streams of output which a program can use to produce this effect - these are known as <code>STDOUT</code> (standard output) and <code>STDERR</code> (standard error). Conventionally, <code>STDOUT</code> is used for the results of the program, and <code>STDERR</code> is reserved for error messages.</p>
<p>We can take advantage of a feature of bash known as <em>output redirection</em> to manipulate the destination of this output - making it possible to store it in a file instead of printing it to the screen. It is even possible to use the output of one command as the <em>input</em> for a subsequent command.</p>
<p>Useful redirection commands:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># redirect the output of **command** to **file** - if file already exists, it will be over-written.</span></a>
<a class="sourceLine" id="cb9-2" title="2">$ <span class="bu">command</span> <span class="op">&gt;</span> file</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co"># append the output of **command** to **file** - if file already exists, the output will be added to the end.</span></a>
<a class="sourceLine" id="cb9-4" title="4">$ <span class="bu">command</span> <span class="op">&gt;&gt;</span> file</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co"># the input of **command** will be read from **file**</span></a>
<a class="sourceLine" id="cb9-6" title="6">$ <span class="bu">command</span> <span class="op">&lt;</span> file</a>
<a class="sourceLine" id="cb9-7" title="7"><span class="co"># the output of **command1** will be used as the input for **command2**</span></a>
<a class="sourceLine" id="cb9-8" title="8">$ <span class="ex">command1</span> <span class="kw">|</span> <span class="ex">command2</span></a></code></pre></div>
<p>All of the redirection commands above work with <code>STDOUT</code>. <code>STDERR</code> will still end up being printed in the terminal. It is also possible to redirect <code>STDERR</code>, though not necessary for anything we’re attempting to accomplish on this course.</p>
<p>We can make use of output redirection to create a file, since the <code>&gt;</code> and <code>&gt;&gt;</code> operators will create a file if it does not already exist.</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Estimated time: 5 - 10 mins</p>
<p> </p>
<p><img src="media/programming.png" title="Exercise Icon" id="id" class="class" width="150" /></p></td>
<td style="text-align: left;"><p><strong>Exercise 4</strong></p>
<p>Run the commands listed below:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1">$ <span class="bu">echo</span> <span class="st">&quot;Hello, World&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2">$ <span class="bu">echo</span> <span class="st">&quot;Hello, World&quot;</span> <span class="op">&gt;</span> ~/myfile.txt</a>
<a class="sourceLine" id="cb10-3" title="3">$ <span class="fu">ls</span> ~</a>
<a class="sourceLine" id="cb10-4" title="4">$ <span class="fu">nano</span> ~/myfile.txt</a></code></pre></div>
<p>Take some time to investigate how <code>nano</code> works - there are some instructions on screen when it opens. Can you figure out how to change the file contents, how to save, and how to exit?</p>
<p>Some other things to consider:</p>
<ul>
<li>What does the <code>echo</code> command do?</li>
<li>How does the addition of <code>&gt; ~/myfile.txt</code> change the behaviour of the <code>echo</code> command?</li>
<li>Is <code>~/myfile.txt</code> a relative or absolute path?</li>
<li>What does <code>^</code> mean in the on-screen help for nano?</li>
<li>Can you figure out how to use <code>echo</code> and <code>&gt;&gt;</code> to add extra content to the file?</li>
</ul></td>
</tr>
</tbody>
</table>
<h3 id="copying-and-moving-files">Copying and Moving files</h3>
<p><code>cp</code> and <code>mv</code> are the Unix commands for copying and moving files, respectively. In both cases they take two compulsory arguments - (1) the name of the file to act on, and (2) the destination location that you want it to end up. As the names suggest, after using <code>cp</code> you will have 2 copies of the file (the original and a copy at the destination), after using <code>mv</code> you will still only have one copy (the one at the destination location - the original will be removed). The destination file location can be in the same directory as the original file, but must have a different name, or it could be in a different directory - in this case the filename can remain the same.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ex">emptyfile</span> myfile.txt</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co"># copy myfile.txt (.bak is a Unix convention for a backup copy)</span></a>
<a class="sourceLine" id="cb11-4" title="4">$ <span class="fu">cp</span> myfile.txt myfile.bak</a>
<a class="sourceLine" id="cb11-5" title="5">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="ex">emptyfile</span> myfile.bak  myfile.txt</a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co"># rename the new file</span></a>
<a class="sourceLine" id="cb11-8" title="8">$ <span class="fu">mv</span> myfile.bak mf.b</a>
<a class="sourceLine" id="cb11-9" title="9">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="ex">emptyfile</span> mf.b  myfile.txt</a></code></pre></div>
<h3 id="working-with-directories">Working with Directories</h3>
<p>Directories are directly analogous to <em>folders</em> in Windows and MacOS. As described previously, they are special files which are capable of containing other files (and indeed other directories). Sensible and well-planned use of directories can impose a logical organisational structure on your filesystem. The command for creating new directories is <code>mkdir</code> (for <strong>m</strong>a<strong>k</strong>e <strong>dir</strong>ectory) - like many other tools we’ve looked at so far, the simplest mode of operation for <code>mkdir</code> is to provide it with a single argument - the name of the directory you want to create.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="co"># make a new directory called **mydir** in the current working directory</span></a>
<a class="sourceLine" id="cb12-2" title="2">$ <span class="fu">mkdir</span> mydir</a>
<a class="sourceLine" id="cb12-3" title="3">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="ex">emptyfile</span>   mydir/  mf.b   myfile.txt</a></code></pre></div>
<p><strong>Note</strong>: The syntax highlighting I use here cannot replicate the colours you will see in your terminal (where directories will be coloured in blue). I’ve addressed this by listing directories with a trailing slash. You can replicate this by adding the -p option to <code>ls</code> - the exact results seen in the block above can be obtained with: <code>ls --color=never -p</code></p>
<p>Other commands already introduced work with directories too - <code>mv</code> will move a directory (and its contents) just like any other file. It is possible to copy whole directories with <code>cp</code> as well, although you do have to add the <code>-r</code> option for this to work correctly:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1"><span class="co"># move file in to new directory</span></a>
<a class="sourceLine" id="cb13-2" title="2">$ <span class="fu">mv</span> mf.b mydir</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co"># move the directory and its contents</span></a>
<a class="sourceLine" id="cb13-4" title="4">$ <span class="fu">mv</span> mydir mynewdir</a>
<a class="sourceLine" id="cb13-5" title="5">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="ex">emptyfile</span> myfile.txt  mynewdir/</a>
<a class="sourceLine" id="cb13-7" title="7">$ <span class="fu">ls</span> mynewdir</a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ex">mf.b</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co"># copy the directory and its contents</span></a>
<a class="sourceLine" id="cb13-10" title="10">$ <span class="fu">cp</span> -r mynewdir mycpdir</a>
<a class="sourceLine" id="cb13-11" title="11">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ex">emptyfile</span> mycpdir/  myfile.txt  mynewdir/</a>
<a class="sourceLine" id="cb13-13" title="13">$ <span class="fu">ls</span> mycpdir</a>
<a class="sourceLine" id="cb13-14" title="14"><span class="ex">mf.b</span></a></code></pre></div>
<h3 id="deleting-files">Deleting Files</h3>
<p>All the commands we’ve looked at so far create files (and directories), however, sometimes it is necessary to delete things too. The command for removing files is <code>rm</code> amd again, the simplest way of using it is with a single argument - the file to be deleted.</p>
<p>Unlike the operating systems you may be used to, there is no request for confirmation when you issue the <code>rm</code> command - the file will be immediately removed from the file system (it also doesn’t go into any sort of recoverable “Trash” folder). For this reason, <code>rm</code> should be treated with caution - especially when used with the <code>-r</code> option (which like <code>cp</code> is used to “recursively” act on all the files in a directory, including the directory itself). If you do want to be prompted for confirmation before deleting a file, you can add the <code>-i</code> option to your <code>rm</code> command.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1"><span class="co"># remove a file</span></a>
<a class="sourceLine" id="cb14-2" title="2">$ <span class="fu">rm</span> emptyfile</a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co"># remove a directory (and contents)</span></a>
<a class="sourceLine" id="cb14-4" title="4">$ <span class="fu">rm</span> -r mycpdir</a>
<a class="sourceLine" id="cb14-5" title="5">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="ex">myfile.txt</span>  mynewdir/</a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co"># remove a file and prompt for confirmation</span></a>
<a class="sourceLine" id="cb14-8" title="8">$ <span class="fu">rm</span> -i myfile.txt</a>
<a class="sourceLine" id="cb14-9" title="9"><span class="ex">rm</span>: remove regular file <span class="st">&#39;myfile.txt&#39;</span>? n</a>
<a class="sourceLine" id="cb14-10" title="10">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb14-11" title="11">$ <span class="fu">ls</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="ex">myfile.txt</span>  mynewdir/</a></code></pre></div>
